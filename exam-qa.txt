QA – Тестване на софтуерни продукти
*Тест*


1. Тестването на софтуерния продукт, трябва да започне:

a) Веднага след като кодът е написан.

b) По време на дизайна на системата.

c) След като изискванията са официално документирани.

d) Колкото се може по-рано, в софтуерния производствен цикъл.


2. Кое твърдение не е вярно:

a) Performance testing може да се извърши, както на ниво Component testing, така и на ниво System testing.

b) Acceptance тестовете не е задължително да включват regression тестове.

c) Верифицирането на системата, не трябва да включва QA специалисти.

d) Тестовите среди, трябва да са възможно най-близки до Live средата.


3. При репортване на проблем на програмист, QA трябва да:

a) трябва да бъде учтив, конструктивен и колкото се може по-полезен.

b) трябва да бъде запознат с изискванията, и да настоява че проблема не е фийчър.

c) трябва да бъде дипломатичен, и внимателен към реакцията на програмиста към критицизъм.

d) Всичките отговори са верни.


4. Под какъв ред трябва да се изпълняват тестовете

a) Първо се изпълняват най-важните (високо приоритетни) тестове.

b) Първо се изпълняват най-трудните тестове.

c) Първо се изпълняват най-лесните тестове.

d) Изпълняват се по реда, в който са измислени.


5. Кое твърдение за black-box тестера не е вярно:

a) трябва да разбира функционалните изисквания.

b) трябва да разбира кода на софтуерния продукт.

c) трябва да е мотивиран да намира проблеми.

d) трябва да е креативен за да намери слабостите на системата.


6. Софтуерна програма валидира числови полета по следния начин:

Стойностите по-малки от 10 се отхвърлят, стойности между 10 и 21 се приемат, стойности по-големи или равни на 22 също се отхвърлят.

Кои от следните входни данни, покриват всички Equivalence класове:

a) 10, 11, 21

b) 3, 20, 21

c) 3, 10, 22

d) 10, 21, 22


7. За същия софтуер за валидация на числови полета от задача 6, кои от следните входни данни, покриват най-добре граничните стойности:

a) 9, 10, 11, 22

b) 9, 10, 21, 22

c) 10, 11, 21, 22

d) 10, 11, 20, 21


8. Числово поле приема като стойност, година на раждане между 1900 и 2004 година. Кои са граничните стойности за тестване на това поле:

a) 0, 1900, 2004, 2005

b) 1900, 2004

c) 1899, 1900, 2004, 2005

d) 1899, 1900, 1901, 1915, 1925, 2003, 2004, 2005


9. Кои са нефункционални тест методи:

a) System testing

b) Usability testing

c) Performance testing

d) Верни са и b. и c. 


10. При компоненто тестване, когато останалите компоненти на системата не са готови, програмистът трябва да имплементира ___?___, който да извика функцията която ще тестваме.

a) Stub

b) Driver

c) Proxy

d) VPN


11. Кои тестове е най-добре да бъдат автоматизирани:

a) Regression testing

b) Integration testing

c) System testing

d) User acceptance testing


12. При приоритизарането на тестовете, най-важното е:

a) да се намерят колкото се може повече тестове.

b) да се проверят високо рисковите функционалности.

c) да се проверят повече функционалности.

d) да се проверят по-лесните функционалности.


13. Главната цел на Acceptance тестването е:

a) Намиране на грешки в системата.

b) Тестване за покриване на бизнес нуждите на системата.

c) Тестване на системата, с помоща на друг софтуерен продукт.

d) Тестване на интеграцията на различните компоненти на системта.


14. Разликата между re-testing и regression testing е:

a) re-testing се извършва от програмисти; regression testing се извършва от QA.

b) re-testing търси неочаквани странични ефекти; regression testing е повтарянето на тези тестове.

c) re-testing е когато повторни изпълняваме даден тест; regression testing търси неочаквани странични ефекти.

d) re-testing се извършва след като дефект е поправен; regression testing се изпълнява преди това.


15. Кое от следните твърдения за System testing не е вярно:

a) System testing най-често се извършва от QA специалисти.

b) Представители на клиента трябва да бъдат включени в System testing.

c) Функционалното тестване се използва по-често от структурното тестване.

d) Дефектите открити при Sysstem testing могат да бъдат скъпи за поправяне.


16. Как може да прецените, колко време би ви било нужно за re-testing:

a) Проверяваме колко време ни е било нужно, за други подобни проекти.

b) Дискутираме с останалите QA в екипа.

c) Нужно ни е същото време, като за regression testing.

d) Верни са и a) и b).


17. Цената за поправяне на бъг:

a) Цената намалява с напредване на проекта и доближаването му до Live.

b) Цината винаги е една и съща. 

c) Цената се увеличава с напредване на проекта и доближаването му до Live.

d) Цената е по-висока, когато проблема е открит в най-ранния стадий.


18. Кое от следните не е цел на тестването:

a) Да се намерят грешки в софтуерния продукт.

b) Да се провери дали софтуера е готов за релийзване.

c) Да се провери удовлетворени ли са клиентските изисквания.

d) Да докаже че софтуера няма никакви грешки.


19. Static Analysis най-добре се описва като:

a) Анализа на софтуерните изисквания.

b) Анализа на тест кейсите.

c) Анализ на програмния код.

d) Използването на black-box тестване.


20. Тестване на граничните стойности е:

a) същото като Equivalence testing.

b) Тестване на граничните стойности, под и над тях, за всеки Equivalence клас.

c) Тестови комбинации на входните данни. 

d) използва се за white-box тестване.


21. Кое от следните не може да се засече при static analysis:

a) изпозлване на грешни типове данни за променливите.

b) грешки в сиситемните изисквания.

c) Недекларирани променливи в кода.

d) Неизползвани функции в кода.


22. Кои от следните са нива на тестване:

a) Risk-based testing, Regression testing и re-testing.

b) Functional testing и Non-functional testing.

c) Component testing, Integration testing и System testing.

d) Performance testing, Stress testing и Load testing.


23. Каква информация не е нужно да бъде въвеждана при репортване на инцидент:

a) Severity и Priority.

b) Как се репродуцира проблема.

c) Как да се поправи проблема.

d) Expected result и Observed result.


24. Кои от следните изисквания могат да бъдат тествани от функционален system test:

a) Системата трябва да изпълнява задачите си за средно 23 часа и 50 мин на ден.

b) Системата трябва да изпълнява задачите си, при повече от 30 потребителя едновременно.

c) Системата трябва да позволява админ потребителя да вижда и-мейл адреса на друг потребител.

d) Сиситемата трябва да потдържа над 12 000 потребители годишно.


25. Какво е Product risk:

a) Вероятността да не успеем да създадем продукта на време.

b) Вероятността продутка да не успее да удовлетвори системните изисквания.

c) Вероятността да не успеем да изтестваме всичко.

d) Вероятноста да не успеем да спазим уговорените срокове.


26. Какво е Project risk:

a) Вероятността продутка да не успее да удовлетвори системните изисквания.

b) Вероятността да не успеем да създадем продукта в уговорените срокове.

c) Вероятността да се появат дефекти след пускането на продукта Live.

d) Вероятността да пропуснем да изртестваме някоя функционалност.


27. В числово поле за въвеждане на възраст, за допълнително осугуряване:

Ако въведем число по-малко от 18, не е нужно да се осигуряваме.

Ако въведем число между 18 и 30, ни дава 20% отстъпка.

Ако въведем число по-голямо от 30, не ни дава отстъпка.

Кои от следните входни данни са от същия Equivalence клас:

a) 17, 18, 19.

b) 29, 30, 31.

c) 18, 29, 30.

d) 17, 29, 31.


28. Кое от следните можем да използваме като метрика за прогреса на тестването:

a) Броя на репортнатите бъгове.

b) Броя на ненамерените бъгове.

c) Броя не тестовете, които още не са изпълнени.

d) Усилията които са ни нужни, за поправяне на бъговете.


29. Полето ID на всеки продукт на дадена e-commerce система, може да приема само числови стойности,

между 10000 и 99999 включително. Коя от следните групи е представител само на валидния Equivalence клас.

a) 9999, 50000, 100000

b) 9999, 10000, 50000, 99999, 10000

c) 1000, 5000, 99999

d) 10000, 50000, 99999


30. Кое от следните е най-важната причина за изпълняване на Risk-based testing:

a) Тестването на абсолютно всичко е невъзможно, поради ограничения във времето.

b) Защото Risk-based testing е най-добрия подход за тестване.

c) Защото Risk-based testing е най-ефективния подход за тестване.

d) Защото софтуерния бизнес е рисков.



